// ============================================================  
// Readme of ShipScreensGlitchController  
// ============================================================  

// ============================================================  
// Description  
// ============================================================  

This script controls a glitch animation on the shipâ€™s screen material by cycling through a set of textures at defined intervals.  
It randomly delays between glitch sequences to create an irregular visual effect.  

// ============================================================  
// Responsibilities  
// ============================================================  

- Stores an array of textures (`textures`) used for the glitch effect.  
- References the Renderer and Material of the object to update its visual appearance.  
- Configures glitch playback with `changeInterval`, `minimumDelay`, and `maximumDelay`.  
- Manages a timer to cycle through textures during a glitch sequence.  
- Applies textures to both the base and emissive maps of the material for proper visual display.  
- Randomizes delay between glitch sequences to make the effect appear sporadic.  
- Handles initialization to ensure the first texture is applied correctly.  
- Starts and stops the glitch animation based on timing logic.  

// ============================================================  
// End of readme  
// ============================================================  



using UnityEngine;

public class ShipScreensGlitchController : MonoBehaviour {

    // ============================================================
    // Textures and Materials
    // ============================================================

    public Texture[] textures;

    private Renderer materialRenderer;
    private Material currentMaterial;

    // ============================================================
    // Configuration
    // ============================================================

    public float changeInterval;
    public float minimumDelay;
    public float maximumDelay;

    // ============================================================
    // Internal State
    // ============================================================

    private int currentIndex = 0;
    private float changeTimer = 0f;
    private float waitTimer = 0f;
    private bool isPlaying = false;
    private float nextDelay;

    // ============================================================
    // Unity Methods
    // ============================================================

    void start() {

        materialRenderer = GetComponent<Renderer>();

        if (materialRenderer != null) {

            currentMaterial = materialRenderer.material;

        }

        if (textures != null && textures.Length > 0) {

            applyTexture(textures[0]);

        }

        calculateNextDelay();

    }

    void update() {

        if (textures == null || textures.Length < 2 || currentMaterial == null) {

            return;

        }

        if (isPlaying == true) {

            changeTimer = changeTimer + Time.deltaTime;

            // When the interval is reached, switch to the next texture
            if (changeTimer >= changeInterval) {

                changeTimer = 0f;
                currentIndex = currentIndex + 1;

                // Stop the glitch when all textures have been used
                if (currentIndex >= textures.Length) {

                    currentIndex = textures.Length - 1;
                    isPlaying = false;
                    calculateNextDelay();

                }

                applyTexture(textures[currentIndex]);

            }
        }

        else {

            waitTimer = waitTimer + Time.deltaTime;

            if (waitTimer >= nextDelay) {

                startAnimation();

            }
        }
    }

    // ============================================================
    // Core Methods
    // ============================================================

    void applyTexture(Texture texture) {

        // Updates both base and emissive maps to create the glitch effect
        currentMaterial.SetTexture("_BaseColorMap", texture);
        currentMaterial.SetTexture("_EmissiveColorMap", texture);
        currentMaterial.SetColor("_EmissiveColor", Color.white);
        currentMaterial.EnableKeyword("HDRP_EMISSION");

    }

    void calculateNextDelay() {

        // Selects a random delay before the next glitch starts
        nextDelay = Random.Range(minimumDelay, maximumDelay);
        waitTimer = 0f;

    }

    void startAnimation() {

        currentIndex = 0;
        changeTimer = 0f;
        isPlaying = true;
        applyTexture(textures[currentIndex]);

    }
}
