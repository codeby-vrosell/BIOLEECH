// ============================================================  
// Readme of SlimeWeaponController  
// ============================================================  

// ============================================================  
// Description  
// ============================================================  

This script manages the collection and burning of slime by the player.  
It handles suction of slime objects, storage in the slime tank, automatic and QTE-based burning, vibration feedback, sound effects, and visual tornado effects.  

// ============================================================  
// Responsibilities  
// ============================================================  

- Detects slime objects in front of the player using raycasts and collects them when cleaning.  
- Stores collected slime in `slimePercent` up to a maximum capacity.  
- Burns slime automatically or via QTE, converting it into bullets.  
- Interfaces with `FPControllerWeapon` to track cleaning, burning, and QTE input states.  
- Plays cleaning and suction sounds, looping them when appropriate.  
- Controls a particle system to visualize slime collection.  
- Provides vibration feedback while cleaning, with configurable intensity and interval.  
- Animates QTE and cleaning states using an Animator component.  
- Updates a tornado shader effect (`_AlphaTornado`) based on cleaning activity.  
- Integrates with `TutorialGameManager` to restrict cleaning and burning actions during early tutorial steps.  
- Allows dynamic registration of new `SlimeMesh` objects to be collected.  
- Ensures dependencies are dynamically found at runtime if not manually assigned.  

// ============================================================  
// End of readme  
// ============================================================  



using NUnit.Framework.Internal;
using System.Linq;
using Unity.VisualScripting;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.HighDefinition;

public class SlimeWeaponController : MonoBehaviour {

    // ============================================================
    // Slime Storage and Burning
    // ============================================================

    private float maxSlime = 100f;
    public float slimePercent = 0f;
    private float burnTimer = 0f;
    public float burnerCooldown;

    public bool isCleaning = false;
    public bool isCleaningSlime = false;

    // ============================================================
    // References
    // ============================================================

    private SlimeMesh[] slimeMeshesScript;
    private SlimeMesh currentSlimeMeshScript;

    public Camera playerCamera;
    private UpgradesController upgradesControllerScript;
    private FPControllerWeapon fpControllerWeaponScript;
    private ShotWeaponController shotWeaponControllerScript;
    private QTEBurner qteBurnerScript;
    private Animator animator;
    private TutorialGameManager tutorialGameManagerScript;

    // ============================================================
    // Cleaning & Slime Suction
    // ============================================================

    [SerializeField] private float vertexMultiplier;
    [SerializeField] private float suctionCooldownTime = 0.5f; // minimum 0.5s between suction sounds
    private float suctionCooldown = 0f;
    private Coroutine suctionCoroutine;

    [SerializeField] private ParticleSystem slimeParticle;

    // ============================================================
    // Vibration Control
    // ============================================================

    [SerializeField] private float minVibration = 0.2f;
    [SerializeField] private float maxVibration = 0.6f;
    [SerializeField] private float vibrationInterval = 0.1f;
    private Coroutine vibrationCoroutine = null;

    // ============================================================
    // Sounds
    // ============================================================

    [Header("Sounds")]
    public AudioClip cleanSound;
    public AudioClip cleanSlimeSound;

    // ============================================================
    // Tornado Effect
    // ============================================================

    public Renderer materialRenderer;
    public string propertyName = "_AlphaTornado";
    public float tornadoSpeed = 2f;
    private float tornadoValue = 0f; // Interpolated value (0-1)

    // ============================================================
    // Layer Masks
    // ============================================================

    public LayerMask slimeLayerMask;

    // ============================================================
    // Unity Lifecycle
    // ============================================================

    void Start() {

        qteBurnerScript = Object.FindFirstObjectByType<QTEBurner>();
        shotWeaponControllerScript = Object.FindFirstObjectByType<ShotWeaponController>();
        tutorialGameManagerScript = FindFirstObjectByType<TutorialGameManager>();

        slimeMeshesScript = new SlimeMesh[0];
        animator = GetComponent<Animator>();
        animator.enabled = false;

    }

    void Update() {

        // Ensure player and dependencies are loaded

        if (fpControllerWeaponScript == null) {

            GameObject playerObj = GameObject.FindWithTag("Player");

            if (playerObj != null) {

                fpControllerWeaponScript = playerObj.GetComponent<FPControllerWeapon>();
                upgradesControllerScript = playerObj.GetComponent<UpgradesController>();

            }
        }

        // Ensure camera reference exists
        if (!playerCamera) {

            GameObject camObj = GameObject.FindWithTag("MainCamera");

            if (camObj != null) {

                playerCamera = camObj.GetComponent<Camera>();

            }
        }

        // Ensure animator exists
        if (animator == null) {

            animator = GetComponent<Animator>();

        }

        handleSuction();
        checkSlimeCapacity();
        checkSlimeReload();
        handleVibration();
        tornadoManager();
        handleSounds();

    }

    // ============================================================
    // Slime Suction & Burning
    // ============================================================

    private void handleSuction() {

        SlimeMesh detectedMesh = detectSlimeMeshToSuck();

        if (isCleaning && detectedMesh != null && slimePercent < maxSlime) {

            float currentRate = calculateSlimePercent(detectedMesh) * vertexMultiplier;
            float amountToStore = Time.deltaTime * currentRate;

            isCleaningSlime = currentRate > 0;

            // Only allow suction during early tutorial steps if below 75%
            if (tutorialGameManagerScript != null && tutorialGameManagerScript.tutorialStep <= 6) {

                if (slimePercent < 75f) {

                    Vector3 aimingPoint = getAimingPoint();
                    detectedMesh.cleanMesh(aimingPoint, Time.deltaTime);
                    storeSlime(amountToStore);

                }
            }

            else {

                Vector3 aimingPoint = getAimingPoint();
                detectedMesh.cleanMesh(aimingPoint, Time.deltaTime);
                storeSlime(amountToStore);

            }
        }

        else {

            isCleaningSlime = false;

        }

        burnTimer = burnTimer + Time.deltaTime;

        // Prevent automatic burning during tutorial
        if (burnTimer >= burnerCooldown) {

            if (tutorialGameManagerScript == null || tutorialGameManagerScript.tutorialStep > 6) {

                burnSlime(upgradesControllerScript.slimeDestroyedUpgrade);
                burnTimer = 0f;

            }
        }
    }

    private SlimeMesh detectSlimeMeshToSuck() {

        Ray ray = playerCamera.ScreenPointToRay(new Vector3(Screen.width / 2, Screen.height / 2));
        RaycastHit hit;
        float range = upgradesControllerScript.cleanRangeUpgrade;

        if (Physics.Raycast(ray, out hit, range, slimeLayerMask)) {

            return hit.collider.GetComponent<SlimeMesh>();

        }

        return null;

    }

    private void checkSlimeReload() {

        if (slimePercent > 1 && fpControllerWeaponScript.burnButtonPressed) {

            // Allow reload only during tutorial step 6 or later
            if (tutorialGameManagerScript == null || tutorialGameManagerScript.inStep6) {

                animator.enabled = true;
                animator.Play("OnQTE");
                fpControllerWeaponScript.burnButtonPressed = false;

            }
        }
    }

    private void storeSlime(float amount) {

        slimePercent = slimePercent + amount;
        slimePercent = Mathf.Clamp(slimePercent, 0, maxSlime);

    }

    private void burnSlime(float amount) {

        if (!fpControllerWeaponScript.isInQTE && slimePercent > 0f) {

            float usedSlime = Mathf.Min(amount, slimePercent);
            int bulletsGenerated = Mathf.FloorToInt(usedSlime);
            shotWeaponControllerScript.bullets = Mathf.Min(shotWeaponControllerScript.bullets + bulletsGenerated, 100);
            slimePercent = slimePercent - usedSlime;

        }
    }

    private float calculateSlimePercent(SlimeMesh mesh) {

        if (mesh != null) {

            return mesh.getSuckedVertices() * 0.01f;

        }

        return 0f;

    }

    public void checkSlimeCapacity() {

        if (slimePercent >= 100f) {

            isCleaning = false;
            animator.enabled = true;
            animator.Play("OnQTE");
            Debug.Log("Slime tank is at 100% capacity.");

        }

        else {

            isCleaning = fpControllerWeaponScript.cleanButtonPressed && !fpControllerWeaponScript.isInQTE && !fpControllerWeaponScript.isShooting && !fpControllerWeaponScript.attackButtonPressed;

        }

        fpControllerWeaponScript.isCleaning = isCleaning;

    }

    public void winQTE() {

        animator.enabled = true;
        animator.Play("OffQTE");

        int bulletsGained = Mathf.Clamp((int)slimePercent, 0, 100);
        shotWeaponControllerScript.bullets = Mathf.Min(shotWeaponControllerScript.bullets + bulletsGained, 100);
        slimePercent = 0f;

    }

    // ============================================================
    // Aiming & QTE
    // ============================================================

    public Vector3 getAimingPoint() {

        if (playerCamera == null) {

            return Vector3.zero;

        }

        Ray ray = playerCamera.ScreenPointToRay(new Vector3(Screen.width / 2, Screen.height / 2));
        RaycastHit hit;
        float range = upgradesControllerScript.cleanRangeUpgrade;

        if (Physics.Raycast(ray, out hit, range, slimeLayerMask)) {

            return hit.point;

        }

        return ray.origin + ray.direction * range;

    }

    public void callStartQTE() {

        qteBurnerScript.startQTE();

    }

    public void animationFinished() {

        animator.enabled = false;

    }

    public void registerSlimeMesh(SlimeMesh newMesh) {

        var list = slimeMeshesScript.ToList();
        list.Add(newMesh);
        slimeMeshes = list.ToArray();

    }

    // ============================================================
    // Vibration
    // ============================================================

    private void handleVibration() {

        if (fpControllerWeaponScript == null) {

            return;

        }

        if (fpControllerWeaponScript.isCleaning) {

            if (vibrationCoroutine == null) {

                vibrationCoroutine = StartCoroutine(vibrateWhileCleaning());

            }
        }

        else {

            if (vibrationCoroutine != null) {

                StopCoroutine(vibrationCoroutine);
                vibrationCoroutine = null;

            }
        }
    }

    private System.Collections.IEnumerator vibrateWhileCleaning() {

        while (fpControllerWeaponScript != null && fpControllerWeaponScript.isCleaning) {

            float intensity = Random.Range(minVibration, maxVibration);
            GamepadVibratorController.instance.startVibration(intensity, vibrationInterval);
            yield return new WaitForSeconds(vibrationInterval);

        }

        vibrationCoroutine = null;

    }

    // ============================================================
    // Tornado Visual Effect
    // ============================================================

    void tornadoManager() {

        if (materialRenderer == null) {

            return;

        }

        float target;

        if (isCleaning) {

            target = 0.043f;

        }

        else {

            target = 0f;

        }

        tornadoValue = Mathf.MoveTowards(tornadoValue, target, Time.deltaTime * tornadoSpeed);

        materialRenderer.material.SetFloat(propertyName, tornadoValue);

    }

    // ============================================================
    // Sounds & Particles
    // ============================================================

    private void handleSounds() {

        if (isCleaning) {

            if (isCleaningSlime) {

                if (suctionCoroutine == null) {

                    suctionCoroutine = StartCoroutine(loopCleaningSound(cleanSlimeSound));

                }

                suctionCooldown = suctionCooldownTime;

            }

            else {

                if (suctionCoroutine != null) {

                    StopCoroutine(suctionCoroutine);
                    suctionCoroutine = null;

                }

                suctionCooldown = suctionCooldown - Time.deltaTime;

                if (suctionCooldown <= 0f) {

                    AudioManager.instance.PlaySoundFXClip(cleanSound, transform, 1f);
                    suctionCooldown = suctionCooldownTime;

                }
            }
        }

        else {

            if (suctionCoroutine != null) {

                StopCoroutine(suctionCoroutine);
                suctionCoroutine = null;

            }

            suctionCooldown = suctionCooldownTime;

        }

        if (isCleaningSlime) {

            slimeParticle.Play();

        }

        else {

            slimeParticle.Stop();

        }
    }

    private System.Collections.IEnumerator loopCleaningSound(AudioClip clip) {

        while (isCleaning) {

            AudioManager.instance.PlaySoundFXClip(clip, transform, 1f);
            yield return new WaitForSeconds(clip.length);

        }

        suctionCoroutine = null;

    }
}
