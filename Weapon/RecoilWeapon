// ============================================================  
// Readme of RecoilWeapon  
// ============================================================  

// ============================================================  
// Description  
// ============================================================  

This script handles the positional and rotational recoil behavior of a weapon.  
It simulates realistic recoil effects for both hip-fire and aiming states, smoothly returning the weapon to its original position and rotation.  

// ============================================================  
// Responsibilities  
// ============================================================  

- Maintains references to the recoil position and rotation points of the weapon.  
- Applies positional and rotational recoil when the weapon is fired.  
- Differentiates between hip-fire and aiming recoil, adjusting intensity and direction accordingly.  
- Smoothly interpolates recoil back to zero using configurable return speeds.  
- Uses `Vector3.Lerp` and `Vector3.Slerp` for smooth, frame-independent motion.  
- Supports randomization in horizontal and roll recoil for a natural feel.  
- Updates the weaponâ€™s local position and rotation each physics frame in `FixedUpdate`.  
- Allows toggling of aiming state to modify recoil behavior dynamically.  

// ============================================================  
// End of readme  
// ============================================================  



using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class RecoilWeapon : MonoBehaviour {

    // ============================================================
    // Reference Points
    // ============================================================

    public Transform recoilPositionPoint;
    public Transform rotationPoint;

    // ============================================================
    // Speed Settings
    // ============================================================

    public float positionalRecoilSpeed;
    public float rotationalRecoilSpeed;

    public float positionalReturnSpeed;
    public float rotationalReturnSpeed;

    // ============================================================
    // Recoil Amounts
    // ============================================================

    public Vector3 recoilRotation;
    public Vector3 recoilKickBack;

    public Vector3 recoilRotationAim;
    public Vector3 recoilKickBackAim;

    // ============================================================
    // Internal State
    // ============================================================

    private Vector3 currentRotationalRecoil;
    private Vector3 currentPositionalRecoil;
    private Vector3 currentRotationEuler;

    // ============================================================
    // Weapon State
    // ============================================================

    public bool isAiming;

    // ============================================================
    // Unity Methods
    // ============================================================

    void fixedUpdate() {

        // Smoothly return recoil values to zero
        currentRotationalRecoil = Vector3.Lerp(currentRotationalRecoil, Vector3.zero, rotationalReturnSpeed * Time.deltaTime);
        currentPositionalRecoil = Vector3.Lerp(currentPositionalRecoil, Vector3.zero, positionalReturnSpeed * Time.deltaTime);

        // Apply positional recoil using spherical interpolation
        recoilPositionPoint.localPosition = Vector3.Slerp(recoilPositionPoint.localPosition, currentPositionalRecoil, positionalRecoilSpeed * Time.fixedDeltaTime);

        // Apply rotational recoil using spherical interpolation
        currentRotationEuler = Vector3.Slerp(currentRotationEuler, currentRotationalRecoil, rotationalRecoilSpeed * Time.fixedDeltaTime);
        rotationPoint.localRotation = Quaternion.Euler(currentRotationEuler);

    }

    // ============================================================
    // Core Methods
    // ============================================================

    public void fire() {

        if (isAiming) {

            // Recoil while aiming: precise vertical kick, random horizontal and roll
            currentRotationalRecoil = currentRotationalRecoil + new Vector3(-recoilRotationAim.x, Random.Range(-recoilRotationAim.y, recoilRotationAim.y), Random.Range(-recoilRotationAim.z, recoilRotationAim.z));

            currentPositionalRecoil = currentPositionalRecoil + new Vector3(Random.Range(-recoilKickBackAim.x, recoilKickBackAim.x), Random.Range(-recoilKickBackAim.y, recoilKickBackAim.y), recoilKickBackAim.z);

        }

        else {

            // Recoil while hip-firing: stronger vertical kick, random horizontal and roll
            currentRotationalRecoil = currentRotationalRecoil + new Vector3(-recoilRotation.x, Random.Range(-recoilRotation.y, recoilRotation.y), Random.Range(-recoilRotation.z, recoilRotation.z));

            currentPositionalRecoil = currentPositionalRecoil + new Vector3(Random.Range(-recoilKickBack.x, recoilKickBack.x), Random.Range(-recoilKickBack.y, recoilKickBack.y), recoilKickBack.z);

        }
    }
}
